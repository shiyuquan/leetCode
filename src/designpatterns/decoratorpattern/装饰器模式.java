/**
 * 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，
 * 它是作为现有的类的一个包装。这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外
 * 的功能。
 *
 * 装饰器模式类图：
 * 接口 --> 接口实现类（被装饰者） * n
 *      --> 接口装饰类（装饰者） --> 装饰实例类 * n
 *
 * 与代理模式的区别
 * 适配器的作用是为了协调新旧接口，代理的作用是在客户端和被代理者之间帮忙做一些额外的事。
 *
 * 回到问题本身，个人感觉装饰模式和代理模式差异在：
 * 1、应用场景上，代理模式是为了帮助目标类增强一些自己不关心的事，比如日志代理，在目标类前后加一些日志。而装饰模式则是用
 *    来增强自身的功能，比如Java的InputStream那些的子类装饰类，提供了一些更方便的接口给我们调用。
 * 2、使用方式上，代理模式一般在代理类中确定了要被代理的目标对象，客户端根本不知道被代理类的存在。而装饰模式中被装饰者对
 *    象需要客户端创建提供，并且可以层层嵌套，层层装饰。
 *
 * @author shiyuquan
 * Create Time: 2019/8/12 21:37
 */
package designpatterns.decoratorpattern;